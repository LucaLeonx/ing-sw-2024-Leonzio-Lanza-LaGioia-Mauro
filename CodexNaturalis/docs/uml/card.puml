@startuml
skinparam linetype ortho
skinparam nodesep 250
skinparam ranksep 100
!startsub CARDS

enum CardColor {
    RED,
    SKYBLUE,
    PURPLE,
    GREEN,
    WHITE
}

enum Symbol{
    PLANT,
    ANIMAL,
    INSECT,
    FUNGI,
    QUILL,
    INKWELL,
    MANUSCRIPT,
    BLANK,
    HIDDEN
    + toString()
}

enum AnglePosition {
    UP_LEFT,
    UP_RIGHT,
    DOWN_LEFT,
    DOWN_RIGHT
}

enum CardOrientation{
    FRONT,
    BACK
}

class Card {
    -id: int
    +Card(color: CardColor, front: CardSide, back: CardSide)
    +getId() : int
    +getColor() : CardColor
    +getSide(side: Side) : CardSide


}

class CardSide {
    + CardSide(centerSymbols: Symbol[0..3], angleSymbols: [AnglePosition, Symbol])
    + getDisplayedSymbols : Symbol[0..*]
    + getCenterSymbols() : Symbol[0..*]
    + getSymbolFromAngle(position : AnglePosition) : Symbol
}

class RandomPicker <T>{
    - elements : Set<T>
    + RandomPicker(Collection<T> elements)
    + isEmpty() : bool
    + extractRandomElement() : Optional<T>
}

class ObjectiveCard {
    - rewardFunction : RewardFunction
    +ObjectiveCard(rewardFunction : RewardFunction)
    +getRewardFunction() : RewardFunction
}

class Deck{
    - topCard : Card[0..1]
    + Deck(cards : Card[])
    + isEmpty() : bool
    + leftCards() : int
    + showTopCard() : Card[0..1]
    + draw() : Card[0..1]
}



Deck "1 " --* "*" Card : - cardPicker {readOnly}
(Deck, Card) .. RandomPicker

Card  -r-* "2" CardSide : - front, back {readOnly}
Card  -l-> CardColor : - color {readOnly}
Card  -d.. CardOrientation : <<dependent>>

CardSide --> RequirementFunction : - playingRequirements {readOnly}
CardSide --> RewardFunction : - playingReward {readOnly}
CardSide -r- "0..3" Symbol : -centerSymbols
CardSide -u-* "4" AnglePosition : - angles<AnglePosition, Symbol>
!endsub
!startsub FUNCTIONS
'Consider making Map<Symbol, int> an object with Stream interface
abstract class GameFunctionFactory <<utility>> {
    + createPointsRewardFunction(points : int) : RewardFunction {static}
    + createCountSymbolsGroupFunction(symbolOccurrences : Map<Symbol, int> {static}
    + createCountSymbolsFunction(symbol : Symbol) : RewardFunction {static}
    + createCoveredAnglesFunction() : RewardFunction {static}
    + createPatternMatchFunction(pattern : Pattern) : RewardFunction {static}
    + createRequiredSymbolsFunction(requiredSymbols : Map<Symbol, int>) : RequirementFunction {static}
}

interface RewardFunction {
    int getPoints(GameField field)
}

interface RequirementFunction {
    bool isSatisfied(GameField field)
}

GameFunctionFactory -u--> RewardFunction
GameFunctionFactory -u--> RequirementFunction
abstract class CardFactory <<utility>>{
    + getCardsList() List<Card> {static}
    + getResourceCardsDeck() : Deck {static}
    + getGoldenCardsDeck() : Deck {static}
    + getObjectiveCardPicker() : RandomPicker<ObjectiveCard> {static}
    + getInitialCardPicker() : RandomPicker<Card> {static}
}

!endsub
CardFactory -l-> Deck : <<creates>>
CardFactory -r..> ObjectiveCard : <<creates>>

@enduml