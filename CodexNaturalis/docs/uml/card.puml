@startuml
skinparam linetype ortho
skinparam nodesep 250
skinparam ranksep 100
!startsub CARDS

enum CardColor {
    RED,
    SKYBLUE,
    PURPLE,
    GREEN,
    WHITE
}

enum Symbol{
    PLANT,
    ANIMAL,
    INSECT,
    FUNGI,
    QUILL,
    INKWELL,
    MANUSCRIPT,
    BLANK,
    HIDDEN
    + toString()
}

enum AnglePosition {
    UP_LEFT,
    UP_RIGHT,
    DOWN_LEFT,
    DOWN_RIGHT
}

enum CardOrientation{
    FRONT,
    BACK
}

class Card {
    -id: int
    +Card(color: CardColor, front: CardSide, back: CardSide)
    +getId() : int
    +getColor() : CardColor
    +getSide(orientation: CardOrientation) : CardSide
}

class CardSide {
    + CardSide(centerSymbols: Collection<Symbol>, angleSymbols: Map<AnglePosition, Symbol>, requirements : RequirementFunction, reward : RewardFunction)
    + getDisplayedSymbols() : Set<Symbol>
    + getCenterSymbols() : Set<Symbol
    + getSymbolFromAngle(position : AnglePosition) : Symbol
    + getPlayingRequirements() : RequirementFunction
    + getReward() : RewardFunction
}

class RandomPicker <T>{
    - elements : Set<T>
    + RandomPicker(Collection<T> elements)
    + isEmpty() : bool
    + extractRandomElement() : Optional<T>
}

class ObjectiveCard {
    - id : int
    - rewardFunction : RewardFunction
    + ObjectiveCard(id : int, rewardFunction : RewardFunction)
    + getId() : int
    + getRewardFunction() : RewardFunction
}

class Deck{
    - topCard : Optional<Card>
    + Deck(cards : Collection<Card>)
    + isEmpty() : bool
    + leftCards() : int
    + showTopCard() : Optional<Card>
    + draw() : Optional<Card>
}



Deck "1 " --* "*" Card : - cardPicker {readOnly}
(Deck, Card) .. RandomPicker

Card  -r-* "2" CardSide : - front, back {readOnly}
Card  -l-> CardColor : - color {readOnly}
Card  -d.. CardOrientation : <<dependent>>

CardSide --> RequirementFunction : - playingRequirements {readOnly}
CardSide --> RewardFunction : - playingReward {readOnly}
CardSide -r- "0..3" Symbol : -centerSymbols
CardSide -u-* "4" AnglePosition : - angles<AnglePosition, Symbol>
!endsub
!startsub FUNCTIONS
'Consider making Map<Symbol, int> an object with Stream interface
abstract class GameFunctionFactory <<utility>> {
    + createPointsRewardFunction(points : int) : RewardFunction {static}
    + createCountSymbolsGroupFunction(symbolOccurrences : Map<Symbol, int> {static}
    + createCountSymbolsFunction(symbol : Symbol) : RewardFunction {static}
    + createCoveredAnglesFunction() : RewardFunction {static}
    + createPatternMatchFunction(pattern : Pattern) : RewardFunction {static}
    + createRequiredSymbolsFunction(requiredSymbols : Map<Symbol, int>) : RequirementFunction {static}
}

interface RewardFunction {
    int getPoints(GameField field)
}

interface RequirementFunction {
    bool isSatisfied(GameField field)
}

GameFunctionFactory -u--> RewardFunction
GameFunctionFactory -u--> RequirementFunction
abstract class CardFactory <<utility>>{
    + getCardsList() List<Card> {static}
    + getResourceCardsDeck() : Deck {static}
    + getGoldenCardsDeck() : Deck {static}
    + getObjectiveCardPicker() : RandomPicker<ObjectiveCard> {static}
    + getInitialCardPicker() : RandomPicker<Card> {static}
}

!endsub
CardFactory -l-> Deck : <<creates>>
CardFactory -r..> ObjectiveCard : <<creates>>

@enduml