@startuml
skinparam nodesep 40
skinparam ranksep 15
skinparam linetype polyline
!startsub CARDS

enum CardColor {
    RED,
    SKYBLUE,
    PURPLE,
    GREEN
}

enum Symbol{
    PLANT,
    ANIMAL,
    INSECT,
    FUNGI,
    QUILL,
    INKWELL,
    MANUSCRIPT,
    BLANK,
    HIDDEN
    + toString()
}

enum AnglePosition {
    UP_LEFT,
    UP_RIGHT,
    DOWN_LEFT,
    DOWN_RIGHT
}

enum Side{
    FRONT,
    BACK
}

class Card {
    -id: int
    +Card(color: CardColor, front: CardSide, back: CardSide)
    +getId() : int
    +getColor() : CardColor
    +getSide(side: Side) : CardSide


}

class CardSide {
    + CardSide(centerSymbols: Set<Symbol>, angleSymbols: Map<AnglePosition, Symbol>)
    + getDisplayedSymbols : Set<Symbol>
    + getCenterSymbols() : Set<Symbol>
    + getSymbolFromAngle(position : AnglePosition) : Symbol
}

class RandomPicker <T>{
    - elements : Set<T>
    + RandomPicker(Collection<T> elements)
    + isEmpty() : bool
    + extractRandomElement() : Optional<T>
}

class ObjectiveCard {
    - rewardFunction : RewardFunction
    +ObjectiveCard(rewardFunction : RewardFunction)
    +getRewardFunction() : RewardFunction
}

class Deck{
    - topCard : Optional<Card>
    + Deck(cards : Collection<Card>)
    + isEmpty() : bool
    + leftCards() : int
    + showTopCard() : Optional<Card>
    + draw() : Optional<Card>
}



Deck "1 " --* "* " Card : - cardPicker {readOnly}
(Deck, Card) .. RandomPicker



Card  -r-* "2" CardSide : - front, back {readOnly}
Card  -l-> CardColor : - color {readOnly}
Card  -d..> Side

CardSide --> RequirementFunction : - playingRequirements {readOnly}
CardSide --> RewardFunction : - playingReward {readOnly}
CardSide -r- Symbol : -centerSymbols : List
CardSide -u-* "4" AnglePosition : - angles<AnglePosition, Symbol>
!endsub
!startsub FUNCTIONS
'Consider making Map<Symbol, int> an object with Stream interface
abstract class GameFunctionFactory <<utility>> {
    + createPointsRewardFunction(points : int) : RewardFunction {static}
    + createCountSymbolsGroupFunction(symbolOccurrences : Map<Symbol, int> {static}
    + createCountSymbolsFunction(symbol : Symbol) : RewardFunction {static}
    + createCoveredAnglesFunction() : RewardFunction {static}
    + createPatternMatchFunction(pattern : Pattern) : RewardFunction {static}
    + createRequiredSymbolsFunction(requiredSymbols : Map<Symbol, int>) : RequirementFunction {static}
}

interface RewardFunction {
    int getPoints(GameField field)
}

interface RequirementFunction {
    bool isSatisfied(GameField field)
}

GameFunctionFactory -u--> RewardFunction
GameFunctionFactory -u--> RequirementFunction
abstract class CardFactory <<utility>>{
    + getCardsList() List<Card> {static}
    + getResourceCardsDeck() : Deck {static}
    + getGoldenCardsDeck() : Deck {static}
    + getObjectiveCardPicker() : RandomPicker<ObjectiveCard> {static}
    + getInitialCardPicker() : RandomPicker<Card> {static}
}

!endsub
CardFactory -l-> Deck
CardFactory -r..> ObjectiveCard

@enduml